<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.0.1">
<procedure name="main">
<interface/>
<body>
<c>* **********************************************************</c>
<c>* 牙齿连接点检测</c>
<c>* 拍牙齿凹面</c>
<c>* **********************************************************</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>Ratio := 1.5</l>
<l>dev_open_window (0, 0, Ratio * 648, Ratio * 486, 'white', WindowHandle)</l>
<l>set_display_font (WindowHandle, 8, 'mono', 'true', 'false')</l>
<l>* dev_set_draw ('margin')</l>
<l>dev_set_line_width (3)</l>
<c></c>
<l>GapRadius := 10</l>
<l>GapDistance := 30</l>
<c>* 读取图像</c>
<l>list_image_files ('D:/MyPrograms/DataSet/halcon/牙模', 'bmp', [], ImageFiles)</l>
<l>for Index := 1 to |ImageFiles| by 1</l>
<l>    read_image (Image, ImageFiles[Index - 1])</l>
<l>    rgb1_to_gray (Image, GrayImage)</l>
<c>    * 区域生长分割</c>
<l>    regiongrowing (GrayImage, Regions, 2, 2, 5, 200000)</l>
<c>    * 确定骨架</c>
<l>    select_shape (Regions, RegionsSkeleton, 'area', 'and', 200000, 2000000)</l>
<l>    union1 (RegionsSkeleton, RegionSkeleton)</l>
<c>    * 大致确定牙齿区域</c>
<l>    union1 (Regions, RegionUnion)</l>
<l>    threshold (GrayImage, Region, 0, 255)</l>
<l>    difference (Region, RegionUnion, RegionDifference)</l>
<l>    reduce_domain (GrayImage, RegionDifference, ImageReduced)</l>
<c>    * 定位牙齿</c>
<l>    binary_threshold (ImageReduced, RegionFrame, 'max_separability', 'light', UsedThreshold)</l>
<l>    erosion_circle (RegionFrame, RegionErosion, GapDistance)</l>
<l>    connection (RegionErosion, ConnectedRegions)</l>
<l>    area_center (ConnectedRegions, Area, Row, Column)</l>
<l>    tuple_max (Area, MaxArea)</l>
<c>    * 通过 area、circularity、roundness 特征选择牙齿</c>
<l>    select_shape (ConnectedRegions, SelectedRegions, ['area','circularity','roundness'], 'and', [0.1 * MaxArea,0.4,0.5], [MaxArea + 1,1,1])</l>
<l>    opening_circle (SelectedRegions, Regions, 0.5 * GapDistance)</l>
<l>    dilation_circle (Regions, RegionsTeeth, GapDistance)</l>
<c>    *</c>
<c>    * 定位连接区域</c>
<c>    * 单独提取牙齿、骨架部分</c>
<l>    dilation_circle (RegionsTeeth, RegionDilation, GapDistance)</l>
<l>    difference (RegionDilation, RegionsTeeth, RegionDifference)</l>
<l>    union1 (RegionDifference, RegionUnion)</l>
<c>    * 抠图</c>
<l>    reduce_domain (GrayImage, RegionUnion, ImageReduced)</l>
<l>    binary_threshold (ImageReduced, Region, 'max_separability', 'light', UsedThreshold)</l>
<c>    * 连接区域</c>
<l>    opening_circle (Region, RegionBridge, 3)</l>
<c>    * 骨架区域</c>
<l>    union1 (RegionDilation, Region)</l>
<l>    difference (RegionFrame, Region, RegionDifference)</l>
<l>    union2 (RegionSkeleton, RegionDifference, RegionSkeleton)</l>
<l>    connection (RegionSkeleton, ConnectedRegions)</l>
<l>    area_center (ConnectedRegions, Area, Row, Column)</l>
<l>    tuple_max (Area, MaxArea)</l>
<l>    select_shape (ConnectedRegions, Regions, 'area', 'and', 1000, MaxArea + 1)</l>
<l>    union1 (Regions, RegionSkeleton)</l>
<l>    union1 (RegionsTeeth, RegionTeeth)</l>
<c>    * 精准定位连接区域</c>
<l>    gen_empty_region (RegionBridgeTeeth)</l>
<l>    gen_empty_region (RegionBridgeFrame)</l>
<l>    connection (RegionBridge, RegionsBridge)</l>
<l>    count_obj (RegionsBridge, NumberBridge)</l>
<l>    for I := 1 to NumberBridge by 1</l>
<l>        select_obj (RegionsBridge, ObjectBridge, I)</l>
<l>        distance_rr_min (ObjectBridge, RegionTeeth, MinDistance, Row1, Column1, Row2, Column2)</l>
<c>        * 条件一：连接到牙齿</c>
<l>        if (MinDistance &lt; 2)</l>
<c>            * 条件二：另一端连接到牙齿、骨架</c>
<l>            dilation_circle (ObjectBridge, RegionDilation, 5)</l>
<c>            * 优先判断连接到骨架的情况</c>
<l>            intersection (RegionSkeleton, RegionDilation, RegionIntersection)</l>
<l>            area_center (RegionIntersection, Area, Row, Column)</l>
<l>            if (Area &gt; 0)</l>
<l>                union2 (RegionBridgeFrame, ObjectBridge, RegionBridgeFrame)</l>
<l>                continue</l>
<l>            endif</l>
<c>            * 连接到牙齿的情况          </c>
<l>            intersection (RegionTeeth, RegionDilation, RegionIntersection)</l>
<l>            connection (RegionIntersection, Regions)</l>
<l>            count_obj (Regions, Number)</l>
<l>            if (Number &gt; 1)</l>
<l>                union2 (RegionBridgeTeeth, ObjectBridge, RegionBridgeTeeth)</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    *</c>
<c>    * 确定切割线坐标</c>
<c>    * 牙齿-牙齿、牙齿-骨架，两种情况单独分析</c>
<c>    * 两次膨胀 → 交集 → 差分</c>
<c>    * 牙齿-骨架，一刀切</c>
<l>    RowStart := []</l>
<l>    ColStart := []</l>
<l>    RowEnd := []</l>
<l>    ColEnd := []</l>
<c>    * 待优化</c>
<c>    * GapRadius 可以针对每个连接点单独自适应</c>
<c>    * 每个连接区域单独判断，取一个最长的交集</c>
<c>    * </c>
<l>    dilation_circle (RegionTeeth, RegionDilationB, GapRadius)</l>
<l>    dilation_circle (RegionTeeth, RegionDilationS, GapRadius - 1)</l>
<l>    intersection (RegionDilationB, RegionBridgeFrame, RegionIntersection)</l>
<l>    intersection (RegionDilationS, RegionBridgeFrame, Region)</l>
<l>    difference (RegionIntersection, Region, RegionBridgeFrame)</l>
<l>    connection (RegionBridgeFrame, ConnectedRegions)</l>
<l>    count_obj (ConnectedRegions, NumberBridge)</l>
<l>    for I := 1 to NumberBridge by 1</l>
<l>        select_obj (ConnectedRegions, ObjectBridge, I)</l>
<c>        * 骨架两个端点，即切割点坐标</c>
<l>        skeleton (ObjectBridge, Skeleton)</l>
<l>        junctions_skeleton (Skeleton, EndPoints, JuncPoints)</l>
<l>        get_region_points (EndPoints, Rows, Columns)</l>
<l>        if (|Rows| &gt; 1)</l>
<l>            distance_pp (Rows[0], Columns[0], Rows[1], Columns[1], Distance)</l>
<l>            RowStart := [RowStart, Rows[0]]</l>
<l>            ColStart := [ColStart, Columns[0]]</l>
<l>            RowEnd := [RowEnd, Rows[1]]</l>
<l>            ColEnd := [ColEnd, Columns[1]]</l>
<l>        endif</l>
<l>    endfor</l>
<c>    *</c>
<c>    * 牙齿-牙齿，切一条</c>
<l>    connection (RegionBridgeTeeth, RegionsBridgeTeeth)</l>
<l>    count_obj (RegionsBridgeTeeth, NumberBridge)</l>
<l>    for I := 1 to NumberBridge by 1 </l>
<l>        select_obj (RegionsBridgeTeeth, ObjectBridge, I)</l>
<l>        dilation_circle (RegionTeeth, RegionDilationB, GapRadius)</l>
<l>        dilation_circle (RegionTeeth, RegionDilationS, GapRadius - 1)</l>
<l>        intersection (RegionDilationB, ObjectBridge, RegionIntersection)</l>
<l>        intersection (RegionDilationS, ObjectBridge, Region)</l>
<l>        difference (RegionIntersection, Region, RegionDifference)</l>
<l>        connection (RegionDifference, ConnectedRegions)</l>
<l>        area_center (ConnectedRegions, Area, Row, Column)</l>
<l>        tuple_sort_index (Area, Indices)</l>
<l>        if ( |Indices| == 1)</l>
<l>            closing_circle (ConnectedRegions, Region, 1)</l>
<l>            skeleton (Region, Skeleton)</l>
<l>            junctions_skeleton (Skeleton, EndPoints, JuncPoints)</l>
<l>            get_region_points (EndPoints, Rows, Columns)</l>
<l>            if (|Rows| &gt; 1)</l>
<l>                distance_pp (Rows[0], Columns[0], Rows[1], Columns[1], Distance)</l>
<l>                RowStart := [RowStart, Rows[0]]</l>
<l>                ColStart := [ColStart, Columns[0]]</l>
<l>                RowEnd := [RowEnd, Rows[1]]</l>
<l>                ColEnd := [ColEnd, Columns[1]]</l>
<l>            endif</l>
<l>        else</l>
<l>            select_shape (ConnectedRegions, Regions, 'area', 'and', Area[Indices[0]] - 1, Area[Indices[1]] + 1)</l>
<l>            select_obj (Regions, ObjectBridge, 1)</l>
<l>            skeleton (ObjectBridge, Skeleton)</l>
<l>            junctions_skeleton (Skeleton, EndPoints, JuncPoints)</l>
<l>            get_region_points (EndPoints, Rows1, Columns1)</l>
<c>            *</c>
<l>            select_obj (Regions, ObjectBridge, 2)</l>
<l>            skeleton (ObjectBridge, Skeleton)</l>
<l>            junctions_skeleton (Skeleton, EndPoints, JuncPoints)</l>
<l>            get_region_points (EndPoints, Rows2, Columns2)</l>
<c>            *</c>
<c>            * 切短的</c>
<l>            distance_pp (Rows1[0], Columns1[0], Rows1[1], Columns1[1], Distance1)</l>
<l>            distance_pp (Rows2[0], Columns2[0], Rows2[1], Columns2[1], Distance2)</l>
<l>            if (Distance1 &gt; Distance2)</l>
<l>                RowStart := [RowStart, Rows2[0]]</l>
<l>                ColStart := [ColStart, Columns2[0]]</l>
<l>                RowEnd := [RowEnd, Rows2[1]]</l>
<l>                ColEnd := [ColEnd, Columns2[1]]</l>
<l>            else</l>
<l>                RowStart := [RowStart, Rows1[0]]</l>
<l>                ColStart := [ColStart, Columns1[0]]</l>
<l>                RowEnd := [RowEnd, Rows1[1]]</l>
<l>                ColEnd := [ColEnd, Columns1[1]]</l>
<l>            endif</l>
<l>        endif</l>
<l>    endfor</l>
<c>    * </c>
<c>    * 进一步优化，把切割线往外延伸 2 个像素点</c>
<c>    * 还要判断切割点是否处在空白区域，针对点做小的偏移</c>
<c>    * pass</c>
<c>    * 显示结果</c>
<l>    dev_display (Image)</l>
<c>    * 把切割线画出来 </c>
<l>    for I := 0 to |RowStart|- 1 by 1</l>
<l>        gen_contour_polygon_xld (Contour, [RowStart[I], RowEnd[I]], [ColStart[I], ColEnd[I]])</l>
<l>        dev_display (Contour)</l>
<l>*         dev_disp_text (RowStart[I] + ' ' + ColStart[I], 'image', RowStart[I], ColStart[I] + 10, 'black', [], [])</l>
<l>*         dev_disp_text (RowEnd[I] + ' ' + ColEnd[I], 'image', RowEnd[I], ColEnd[I] + 10, 'black', [], [])</l>
<l>    endfor</l>
<l>    dev_disp_text (|RowStart|, 'image', 12, 12, 'black', [], [])</l>
<l>    dev_disp_text (RowStart$'.4d' + ' ' + ColStart$'.4d' + ', ' + RowEnd$'.4d' + ' ' + ColEnd$'.4d', 'image', 40, 12, 'black', [], [])</l>
<l>    if (Index &lt; |ImageFiles|)</l>
<l>        disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>        stop ()</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
